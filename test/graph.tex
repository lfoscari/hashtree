\documentclass[a4paper]{article}

\usepackage{pgfplots}
\pgfplotsset{compat=1.17}

\usepackage[margin=1in]{geometry}

\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage[boxed]{algorithm2e}

% \setlength{\parindent}{0pt}
% \setlength{\parskip}{10pt}

\title{Analisi dell'HH-tree}
\author{Luigi Foscari}
\date{}

\begin{document}

\maketitle

\section{Parametri e metriche}
I parametri della struttura dati sono
\begin{itemize}
	\item $m$ la dimensione massima delle foglie.
	\item $b$ la taglia delle tabelle di hash nei nodi.
	\item $n$ il numero di elementi inseriti (spesso sconosciuto a priori).
\end{itemize}
Le metriche analizzate sono
\begin{itemize}
	\item \textit{Usage} o utilizzo è la percentuale $\in [0, 1]$ di riempimento delle foglie rispetto ad $m$.
	\item \textit{Depth} è la profondità $\in \mathbb{N}$ dell'albero.
\end{itemize}

\section{Relazione tra i parametri e le metriche}

Le seguenti analisi hanno mostrano come gli unici valori \textit{sensati} per $m$ e $b$ sono quelli minori di $n$ e che conviene allontanarsi da valori troppo bassi per entrambi.

È necessario distinguere due implementazioni, nella prima, chiamata \textit{rigida}, il parametro $m$ rimane inalterato in tutta la struttura, nella seconda, chiamata \textit{adattiva}, $m$ è incrementato di 1 per ogni figlio, quindi una foglia a prodondità $t$ avrà una lunghezza massima $m + t$.

% La soluzione migliore per b e m è log2(n)?

\subsection{Implementazione rigida}

L'implementazione in question presenta una condizione sui parametri, nel caso in cui $b = 1$ e $m < n$ è invevitable una ricorsione infinita alla prima scissione, perchè non è possibile inserire tutti gli elementi in un solo bucket, ma non è neanche possibile utilizzare più di un bucket. Perciò $b > 1$ o, meno efficientemente, $m \geq n$.

\begin{itemize}
	\item Riguardo a $b$ possiamo dire che
	\begin{itemize}
		\item Se $b = 2$ l'albero è binario, considerando che l'hashing è universale il valore atteso di utilizzo delle foglie è $1/2$, La profondità è
			$$ \log_2 \left( \frac{m}{2} + 1 \right) - 1. $$
		\item Se $b \geq n$ in valore atteso la profondità è 1 e l'utilizzo è $n / b$.
	\end{itemize}
	\item Riguardo ad $m$ possiamo dire che
	\begin{itemize}
		\item Se $m = 1$ ogni foglia contiene al massimo un elemento, quindi in valore atteso l'utilizzo è $1 / b$ e la profondità è al massimo $n$.
		\item Se $m = n$ l'utilizzo è sempre uguale a $m / b$, mentre la profondità è sempre 1.
	\end{itemize}
\end{itemize}

\subsection{Implementazione adattiva}

\begin{itemize}
	\item Riguardo a $b$ possiamo dire che
	\begin{itemize}
		\item Se $b = 1$ l'utilizzo è sempre 1, perchè c'è una scissione ad ogni inserimento dopo l'$m$-esimo, mentre la profondità è $n - m + 1$.
		\item Se $b = n$ l'utilizzo ha un valore atteso pari a $n/m$ e la profondità $1$, ipotizzando che l'hashing utilizzato sia universale.
	\end{itemize}
	\item Riguardo ad $m$ possiamo dire che
	\begin{itemize}
		\item Al crescere di $m$ da 1 ad $n$ la profondità e l'utilizzo tendono a scendere. 
		\item Dal momento in cui $m = n$ non avvengono scissioni, perciò la profondità sarà sempre 1 e l'utilizzo al 100\%.
	\end{itemize}
\end{itemize}

% Definito $X_t$ come l'evento che un elemento generico raggiunta la profondità $t$ dell'albero senza essere inserito abbiamo che
% $$ P(X_t \, | \, X_{t-1}, X_{t-2}, \dots, X_0 ) = \frac{1}{m + t} $$

\pagebreak

\section{\texttt{MAGIC Gamma Telescope Dataset}}

È stato utilizzato un subset di $n = 50$ righe del \texttt{MAGIC Gamma Telescope Dataset}. Per valori di $m$ e $b$ tra 1 e $n$ sono stati calcolati utilizzo e profondità medi su 10 permutazioni. Questi sono i risultati.

\begin{center}
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Usage}, zmin=0.0, zmax=1.0, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=avg_usage, col sep=comma] {../resources/magic/magic04.out};
		\end{axis}
	\end{tikzpicture}%
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Usage}, zmin=0.0, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=std_usage, col sep=comma] {../resources/magic/magic04.out};
		\end{axis}
	\end{tikzpicture}

	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Depth}, zmin=1, zmax=50, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=avg_depth, col sep=comma] {../resources/magic/magic04.out};
		\end{axis}
	\end{tikzpicture}%
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Depth}, zmin=0.0, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=std_depth, col sep=comma] {../resources/magic/magic04.out};
		\end{axis}
	\end{tikzpicture}

	\begin{tikzpicture}
		\begin{axis}[
			xlabel={$m$}, xmin=1, xmax=50,
			ylabel={$b$}, ymin=1, ymax=50,
			zlabel={Number of accesses}, zmin=0.0, zmajorgrids=true,
			width=\textwidth * 0.8
		]
		\addplot3 [scatter, only marks, mark=+]
			table [x=m, y=b, z=avg_access, col sep=comma] {../resources/magic/magic04.out};
		\end{axis}
	\end{tikzpicture}
\end{center}

\pagebreak

\section{\texttt{Cloud DataSet}}

È stato utilizzato un subset di $n = 50$ righe del \texttt{Cloud DataSet}. Per valori di $m$ e $b$ tra 1 e $n$ sono stati calcolati utilizzo e profondità medi su 10 permutazioni. Questi sono i risultati.

\begin{center}
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Usage}, zmin=0.0, zmax=1.0, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=avg_usage, col sep=comma] {../resources/cloud/cloud.out};
		\end{axis}
	\end{tikzpicture}%
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Usage}, zmin=0.0, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=std_usage, col sep=comma] {../resources/cloud/cloud.out};
		\end{axis}
	\end{tikzpicture}

	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Depth}, zmin=1, zmax=50, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=avg_depth, col sep=comma] {../resources/cloud/cloud.out};
		\end{axis}
	\end{tikzpicture}%
	\begin{tikzpicture}
		\begin{axis}[
				xlabel={$m$}, xmin=1, xmax=50,
				ylabel={$b$}, ymin=1, ymax=50,
				zlabel={Depth}, zmin=0.0, zmajorgrids=true,
				width=\textwidth * 0.5
			]
			\addplot3 [scatter, only marks, mark=+]
				table [x=m, y=b, z=std_depth, col sep=comma] {../resources/cloud/cloud.out};
		\end{axis}
	\end{tikzpicture}

	\begin{tikzpicture}
		\begin{axis}[
			xlabel={$m$}, xmin=1, xmax=50,
			ylabel={$b$}, ymin=1, ymax=50,
			zlabel={Number of accesses}, zmin=0.0, zmajorgrids=true,
			width=\textwidth * 0.8
		]
		\addplot3 [scatter, only marks, mark=+]
			table [x=m, y=b, z=avg_access, col sep=comma] {../resources/cloud/cloud.out};
		\end{axis}
	\end{tikzpicture}
\end{center}

\pagebreak

\section{Strutture dati analoghe}

Un HH-tree con $k$ mappe di feature su un universo $\mathcal{X}$ permette di fare ricerca su più campi, espressi come feature degli elementi di $\mathcal{X}$. È possibile ottenere una struttura dati quasi analoga tramite l'utilizzo di molteplici tabelle di hash: gli elementi inseriti $S \subseteq \mathcal{X}$ sono conservati in un array $A$, sono create inoltre $k$ tabelle di hash di taglia $b$, ad ognuna è associata una mappa.
\begin{itemize}
	\item L'inserimento di un valore $x \in \mathcal{X}$ è effettuato aggiungendo all'array $x$ e per ognuna delle tabelle di hash calcolare la posizione di $x$ e inserire nella lista di collisione la posizione di $x$ all'interno dell'array.
	\item La ricerca su un insieme di chiavi è definita nel seguente algoritmo
	\begin{algorithm}
		\DontPrintSemicolon

		\;

		\KwData{$A$ insieme degli elementi, $C$ chiavi, $T$ tabelle}
		\KwOut{Risultato della ricerca su $c$ chiavi}

		Sia $R$ una copia di $A$ \;
		\For{$i = 1, \dots, |T|$} {
			\For{$j = 1, \dots, |C|$} {
				Rimuovi da $R$ ogni elemento che non compare in $T[i][j]$ \;
			}
		}

		\Return $R$ \;

		\;
	\end{algorithm}
	\item La cancellazione di effettua rimuovendo l'indice dell'elemento da ogni tabella di hash e l'elemento da $A$.
\end{itemize}

Quindi l'inserimento è lineare su $k$, mentre la ricerca con un insieme di chiavi $C$ è $O(|T||C| + n) = O(|T|k + n)$\footnote{$|C| \leq k$}. Lo spazio occupato è invece $O(n + |T|n)$. Inoltre l'inserimento occupa spazio $O(n)$.

\end{document}